// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ReportType {
  PALM
  NUM
  ASTRO
  SYNTH
}

enum ReportStatus {
  DRAFT
  READY
  FAILED
}

enum PalmSide {
  LEFT
  RIGHT
}

enum PalmScanStatus {
  DRAFT
  ANALYZING
  READY
  BAD_PHOTO
  FAILED
}

enum ShareStatus {
  ACTIVE
  REVOKED
  EXPIRED
}

enum Handedness {
  RIGHT
  LEFT
  AMBI
}

// ✅ ДЛЯ НУМЕРОЛОГИИ (КОД СУДЬБЫ)
enum NumMode {
  DATE
  COMBO
  COMPAT
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  telegramId String @unique
  username   String?
  firstName  String?
  lastName   String?

  locale String? @default("ru")
  meta   Json?   @db.Json

  profile   Profile?
  palmScans PalmScan[]
  reports   Report[]
  shares    ReportShare[]

  @@index([createdAt])
  @@index([telegramId])
}

model Profile {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  dob       DateTime?
  birthTime String?
  birthCity String?
  birthMeta Json? @db.Json

  displayName String?

  handedness Handedness?

  @@index([userId])
  @@index([dob])
}

model PalmScan {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  leftImageUrl  String?
  rightImageUrl String?

  leftMeta  Json? @db.Json
  rightMeta Json? @db.Json

  status PalmScanStatus @default(DRAFT)

  aiJson Json? @db.Json
  aiText String?

  confidence  Float?
  qualityFlag Boolean @default(false)
  qualityNote String?

  errorCode String?
  errorText String?

  reports Report[]

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([userId, status, createdAt])
}

model Report {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type   ReportType
  status ReportStatus @default(DRAFT)

  json Json? @db.Json
  text String?

  palmScanId String?
  palmScan   PalmScan? @relation(fields: [palmScanId], references: [id], onDelete: SetNull)

  // ✅ НУМЕРОЛОГИЯ (структурируем, но основное всё равно можно хранить в input Json)
  numMode   NumMode?
  numDob1   DateTime?
  numName1  String?
  numDob2   DateTime?
  numName2  String?

  input      Json?  @db.Json
  confidence Float?

  errorCode String?
  errorText String?

  shares ReportShare[]

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([userId, type, createdAt])
  @@index([palmScanId])

  @@index([numMode])
  @@index([numDob1])
  @@index([numDob2])
}

model ReportShare {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  reportId String
  report   Report  @relation(fields: [reportId], references: [id], onDelete: Cascade)

  status ShareStatus @default(ACTIVE)

  token     String   @unique
  expiresAt DateTime?
  revokedAt DateTime?

  maxViews Int?
  views    Int @default(0)

  meta Json? @db.Json

  @@index([userId])
  @@index([reportId])
  @@index([status])
  @@index([expiresAt])
  @@index([token])
}
